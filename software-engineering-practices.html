<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Software Engineering Practices ‚Äî Professional AI Development</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Mono:wght@400;500&family=Clash+Display:wght@400;600;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=Syne+Mono&display=swap');

:root {
  --bg: #04040a;
  --accent: #7b2fff;
  --hot: #ff2d78;
  --cool: #00e5ff;
  --warm: #ffb800;
  --green: #00ff9d;
  --text: #e0e0f0;
  --muted: #4a4a6a;
  --card: #0a0a14;
  --border: rgba(255,255,255,0.07);
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html { scroll-behavior: smooth; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Syne', sans-serif;
  overflow-x: hidden;
  line-height: 1.8;
}

/* Starfield bg */
body::before {
  content: '';
  position: fixed; inset: 0; z-index: 0;
  background:
    radial-gradient(ellipse 100% 60% at 50% 0%, rgba(123,47,255,0.12) 0%, transparent 60%),
    radial-gradient(ellipse 60% 40% at 0% 100%, rgba(0,229,255,0.06) 0%, transparent 60%);
  pointer-events: none;
}

.wrap { position: relative; z-index: 1; max-width: 1100px; margin: 0 auto; padding: 0 28px; }

/* NAV */
nav {
  position: sticky; top: 0; z-index: 100;
  background: rgba(4,4,10,0.9);
  backdrop-filter: blur(24px);
  border-bottom: 1px solid var(--border);
  padding: 14px 28px;
  display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
}
.nav-brand { font-family: 'Bebas Neue', sans-serif; font-size: 20px; color: var(--accent); margin-right: auto; letter-spacing: 2px; }
.nav-pill {
  font-family: 'Syne Mono', monospace; font-size: 10px; letter-spacing: 2px;
  padding: 5px 12px; border-radius: 20px; border: 1px solid rgba(123,47,255,0.4);
  color: rgba(123,47,255,0.8); text-decoration: none; transition: all 0.2s;
}
.nav-pill:hover, .nav-pill.active { background: rgba(123,47,255,0.15); border-color: var(--accent); color: #fff; }

/* HERO */
.hero { padding: 90px 0 50px; }
.hero-eyebrow {
  font-family: 'Syne Mono', monospace; font-size: 11px; letter-spacing: 4px;
  color: var(--accent); text-transform: uppercase; margin-bottom: 18px;
  display: flex; align-items: center; gap: 12px;
}
.hero-eyebrow::after { content: ''; flex: 1; height: 1px; background: rgba(123,47,255,0.3); }

.hero h1 {
  font-family: 'Bebas Neue', sans-serif;
  font-size: clamp(48px, 10vw, 100px);
  line-height: 0.92; margin-bottom: 28px;
  color: #fff;
}

.hero-desc { max-width: 750px; font-size: 16px; color: rgba(210,210,240,0.72); line-height: 1.8; margin-bottom: 40px; }

/* SECTION */
section { padding: 70px 0; border-top: 1px solid var(--border); }
.section-label { font-family: 'Syne Mono', monospace; font-size: 10px; letter-spacing: 4px; color: var(--accent); text-transform: uppercase; margin-bottom: 16px; }
.section-title { font-family: 'Bebas Neue', sans-serif; font-size: clamp(36px, 6vw, 64px); line-height: 1; margin-bottom: 40px; color: #fff; }

/* PRACTICE CARD */
.practice-card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 40px;
  margin-bottom: 36px;
  border-left: 4px solid var(--practice-color, var(--accent));
  transition: all 0.3s;
}

.practice-card:hover {
  border-color: var(--practice-color, var(--accent));
  background: linear-gradient(135deg, rgba(255,255,255,0.02) 0%, transparent 100%);
  transform: translateY(-2px);
}

.practice-header {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-bottom: 28px;
}

.practice-icon {
  font-size: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 60px;
}

.practice-title-section h2 {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 32px;
  color: var(--practice-color, var(--accent));
  margin-bottom: 8px;
  letter-spacing: 1px;
}

.practice-subtitle {
  font-size: 14px;
  color: rgba(200,200,220,0.8);
  font-style: italic;
}

.practice-body {
  font-size: 15px;
  color: rgba(210,210,240,0.88);
  line-height: 1.9;
  margin-bottom: 28px;
}

.practice-body p {
  margin-bottom: 16px;
}

.practice-body strong {
  color: #fff;
}

.code-block {
  background: rgba(0,0,0,0.5);
  border: 1px solid rgba(0,229,255,0.2);
  border-radius: 12px;
  padding: 24px;
  margin: 24px 0;
  font-family: 'DM Mono', monospace;
  font-size: 13px;
  color: #fff;
  overflow-x: auto;
  line-height: 1.6;
}

.code-comment {
  color: #5c7a8a;
}

.code-keyword {
  color: var(--accent);
}

.code-string {
  color: var(--green);
}

.code-number {
  color: var(--warm);
}

.code-function {
  color: var(--cool);
}

.teaching-box {
  background: rgba(123,47,255,0.1);
  border-left: 4px solid var(--accent);
  padding: 24px;
  border-radius: 10px;
  margin: 28px 0;
  font-size: 15px;
  color: rgba(210,210,240,0.9);
  line-height: 1.8;
}

.teaching-box strong {
  color: #fff;
}

.comparison-box {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 20px;
  margin: 28px 0;
}

.comparison-card {
  background: rgba(0,0,0,0.3);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 24px;
  border-left: 3px solid var(--comp-color, var(--accent));
}

.comp-title {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 16px;
  color: var(--comp-color, var(--accent));
  margin-bottom: 14px;
  letter-spacing: 1px;
}

.comp-content {
  font-size: 13px;
  color: rgba(200,200,220,0.85);
  line-height: 1.8;
}

/* IMPACT BOX */
.impact-box {
  background: linear-gradient(135deg, rgba(123,47,255,0.15) 0%, rgba(0,229,255,0.08) 100%);
  border: 1px solid rgba(123,47,255,0.3);
  border-radius: 14px;
  padding: 32px;
  margin-top: 32px;
}

.impact-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 28px;
}

.impact-item {
  padding: 24px;
  background: rgba(0,0,0,0.2);
  border-radius: 10px;
  border-left: 4px solid var(--impact-color, var(--accent));
}

.impact-item-title {
  font-family: 'Syne Mono', monospace;
  font-size: 12px;
  letter-spacing: 2px;
  color: var(--impact-color, var(--accent));
  text-transform: uppercase;
  margin-bottom: 14px;
  font-weight: 600;
}

.impact-item-content {
  font-size: 13px;
  color: rgba(200,200,220,0.88);
  line-height: 1.8;
}

/* BEST PRACTICES LIST */
.best-practices {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 32px;
  margin: 28px 0;
}

.practices-title {
  font-family: 'Syne Mono', monospace;
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--practice-color, var(--accent));
  text-transform: uppercase;
  margin-bottom: 20px;
  font-weight: 600;
}

.practice-list {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 16px;
}

.practice-item {
  background: rgba(0,0,0,0.3);
  padding: 16px;
  border-radius: 8px;
  border-left: 3px solid var(--practice-color, var(--accent));
}

.practice-item-title {
  font-size: 13px;
  color: #fff;
  margin-bottom: 6px;
  font-weight: 600;
}

.practice-item-desc {
  font-size: 12px;
  color: rgba(200,200,220,0.8);
  line-height: 1.6;
}

/* TIMELINE */
.timeline {
  position: relative;
  padding: 40px 0;
}

.timeline-item {
  padding: 28px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 10px;
  margin-bottom: 24px;
  margin-left: 40px;
  position: relative;
}

.timeline-item::before {
  content: '';
  position: absolute;
  left: -32px;
  top: 32px;
  width: 16px;
  height: 16px;
  background: var(--accent);
  border-radius: 50%;
  border: 3px solid var(--bg);
}

.timeline-item::after {
  content: '';
  position: absolute;
  left: -24px;
  top: 48px;
  width: 2px;
  height: 44px;
  background: rgba(123,47,255,0.3);
}

.timeline-item:last-child::after {
  display: none;
}

.timeline-title {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 18px;
  color: var(--cool);
  margin-bottom: 10px;
  letter-spacing: 1px;
}

.timeline-desc {
  font-size: 14px;
  color: rgba(200,200,220,0.85);
  line-height: 1.8;
}

/* FOOTER */
footer {
  padding: 60px 0 40px;
  border-top: 1px solid var(--border);
  text-align: center;
}

.footer-text {
  font-family: 'Syne Mono', monospace;
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--muted);
  text-transform: uppercase;
}

/* RESPONSIVE */
@media (max-width: 768px) {
  .hero { padding: 60px 0 40px; }
  section { padding: 50px 0; }
  .practice-header { flex-direction: column; align-items: flex-start; }
  .impact-grid { grid-template-columns: 1fr; }
  .comparison-box { grid-template-columns: 1fr; }
}

</style>
</head>
<body>

<nav>
  <div class="nav-brand">SOFTWARE ENGINEERING</div>
  <a href="#version-control" class="nav-pill">Git</a>
  <a href="#testing" class="nav-pill">Testing</a>
  <a href="#organization" class="nav-pill">Organization</a>
  <a href="#deployment" class="nav-pill">Deployment</a>
</nav>

<div class="wrap">

  <!-- HERO -->
  <section class="hero">
    <div class="hero-eyebrow">From Scripts to Systems</div>
    <h1>Software Engineering Practices</h1>
    <p class="hero-desc">There's a crucial difference between writing code that works and writing code that other people can understand, maintain, and build upon. Beginners write scripts that run once and produce results. Professionals write code that lives in repositories, gets tested automatically, collaborates smoothly with teammates, and can be modified months later without breaking. These practices aren't optional add-ons for large teams. They're foundational skills that separate working systems from fragile hacks. Understanding version control, testing, code organization, and deployment transforms you from someone who writes code into someone who engineers systems. This is the difference between amateur and professional development, and it's the difference that matters when your code powers real applications.</p>
  </section>

  <!-- VERSION CONTROL -->
  <section id="version-control">
    <div class="section-label">Collaboration and History</div>
    <h2 class="section-title">Version Control with Git</h2>

    <div class="practice-card" style="--practice-color: var(--green);">
      <div class="practice-header">
        <div class="practice-icon">üîÑ</div>
        <div class="practice-title-section">
          <h2>Git: The Standard Version Control System</h2>
          <div class="practice-subtitle">Track changes, collaborate safely, maintain complete project history</div>
        </div>
      </div>

      <div class="practice-body">
        Version control is how you track changes to your code over time. Imagine writing a document where you can see every edit ever made, who made it, when they made it, and why. Git is that for code. Every change you make gets recorded in a commit‚Äîa snapshot of your code at that moment with a message explaining what you changed and why. This creates a complete history of your project.

        The power of Git becomes obvious in collaboration. When you work with teammates, everyone is editing different parts of the code simultaneously. Git manages these parallel changes, merging them together intelligently. It tells you when two people edited the same line (a conflict) and helps you resolve it. Without version control, collaboration would be chaos‚Äîoverwriting each other's work, losing changes, having no way to know who changed what.

        But even working alone, Git is invaluable. You can revert to any previous version if you make a mistake. You can create branches to experiment safely without touching main code. You can review your own changes before committing them. Most importantly, Git creates accountability and transparency‚Äîevery change is recorded with your name and a message explaining it.
      </div>

      <div class="teaching-box">
        Think of Git as a detailed history book for your code. Each commit is a chapter that documents a specific change. The branch structure lets you write multiple storylines simultaneously. At any point, you can jump back to any chapter, see what was different, understand why changes were made. This history is invaluable for understanding evolution of projects and debugging mysterious bugs.
      </div>

      <div class="code-block">
<span class="code-comment"># Initialize a new Git repository</span>
git init

<span class="code-comment"># Clone an existing repository</span>
git clone https://github.com/user/project.git

<span class="code-comment"># Check status: what files changed?</span>
git status

<span class="code-comment"># Stage changes for commit (tell Git what to save)</span>
git add models.py                  <span class="code-comment"># Add specific file</span>
git add .                           <span class="code-comment"># Add all changed files</span>

<span class="code-comment"># Commit: save staged changes with a message</span>
git commit -m <span class="code-string">"Add neural network model class"</span>

<span class="code-comment"># Create and switch to a new branch (safe experimentation)</span>
git checkout -b feature/attention-mechanism
<span class="code-comment"># ... make changes ...</span>
git commit -m <span class="code-string">"Implement attention layer"</span>

<span class="code-comment"># Switch back to main branch</span>
git checkout main

<span class="code-comment"># Merge branch back into main (integrate the feature)</span>
git merge feature/attention-mechanism

<span class="code-comment"># View commit history</span>
git log --oneline               <span class="code-comment"># Short summary</span>

<span class="code-comment"># Push changes to remote repository (GitHub, GitLab)</span>
git push origin main

<span class="code-comment"># Pull updates from remote (get teammate's changes)</span>
git pull origin main

<span class="code-comment"># Undo last commit (keep changes)</span>
git reset --soft HEAD~1

<span class="code-comment"># Undo last commit (discard changes)</span>
git reset --hard HEAD~1
      </div>

      <div class="best-practices">
        <div class="practices-title">Git Best Practices</div>
        <div class="practice-list">
          <div class="practice-item">
            <div class="practice-item-title">Meaningful Commit Messages</div>
            <div class="practice-item-desc">Write clear messages explaining what changed and why. Future you (and teammates) will thank you when debugging issues months later.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Frequent Small Commits</div>
            <div class="practice-item-desc">Commit often with logical changes. One commit = one logical change makes history readable and rollbacks precise.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Branch for Features</div>
            <div class="practice-item-desc">Create branches for experiments and features. Keep main stable and working at all times.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Pull Before Pushing</div>
            <div class="practice-item-desc">Always pull latest changes before pushing. This prevents merge conflicts and keeps history clean.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">.gitignore Files</div>
            <div class="practice-item-desc">Tell Git what NOT to track (virtual environments, large datasets, credentials). Don't commit secrets or temporary files.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Pull Requests for Review</div>
            <div class="practice-item-desc">Before merging to main, create pull requests. Let teammates review and discuss changes. This catches bugs and shares knowledge.</div>
          </div>
        </div>
      </div>

      <div class="impact-box">
        <div class="impact-grid">
          <div class="impact-item" style="--impact-color: var(--green);">
            <div class="impact-item-title">üéØ Where It's Used</div>
            <div class="impact-item-content">Every professional software project uses Git. Research papers have repositories. Competitions commit code. Open source is Git-based. Machine learning projects are Git repositories. If you're working with code professionally, you're using Git.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--cool);">
            <div class="impact-item-title">üí° Why It Matters</div>
            <div class="impact-item-content">Git enables collaboration safely. It provides complete history of changes. It lets you experiment without fear. In machine learning where experimentation is constant, Git protects you from losing work. It's not a convenience‚Äîit's essential.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--warm);">
            <div class="impact-item-title">‚è±Ô∏è When You Need It</div>
            <div class="impact-item-content">From the first line of code. Initialize Git immediately on any project. This habit prevents disaster when code needs to be recovered or collaborated on. Even personal projects benefit from version control for learning and reflection.</div>
          </div>
        </div>
      </div>
    </div>

  </section>

  <!-- TESTING AND QUALITY -->
  <section id="testing">
    <div class="section-label">Quality Assurance and Reliability</div>
    <h2 class="section-title">Testing: Ensuring Code Works Correctly</h2>

    <div class="practice-card" style="--practice-color: var(--cool);">
      <div class="practice-header">
        <div class="practice-icon">üß™</div>
        <div class="practice-title-section">
          <h2>Unit Testing and Test-Driven Development</h2>
          <div class="practice-subtitle">Verify code works before deployment, catch regressions automatically</div>
        </div>
      </div>

      <div class="practice-body">
        A test is code that verifies your code works correctly. You write a function that checks if a specific behavior is true. If the check fails, the test fails and alerts you. Without tests, you deploy code hoping it works, and it often doesn't‚Äîat least not for edge cases users will eventually hit. With tests, you catch bugs before deployment.

        Unit tests check individual functions in isolation. You call a function with specific inputs and verify it produces the expected output. For a function that normalizes vectors, you test that it correctly normalizes, that it handles zero vectors, that it works with negative numbers. These tests are fast and specific, catching bugs in individual components.

        Integration tests check that components work together correctly. Machine learning involves data flowing through preprocessing, feature engineering, model inference. Integration tests verify the entire pipeline produces reasonable outputs on realistic data. Unit and integration tests together provide comprehensive coverage.

        Test-driven development (TDD) reverses the normal order: write tests first, then write code to pass the tests. This sounds backwards, but it's powerful. Writing tests first forces you to think about specifications before implementation. You write exactly what's needed, no more, no less. Tests become documentation of intended behavior. The codebase is immediately testable because tests drove the design.
      </div>

      <div class="teaching-box">
        Tests are insurance against disaster. You might be confident code works today, but three months from now when you modify something subtly, a test catches the regression immediately. In machine learning where preprocessing bugs can silently corrupt models, tests are essential. A test that verifies "after preprocessing, all features are normalized to [0,1]" will catch bugs that would otherwise hide in the results.
      </div>

      <div class="code-block">
<span class="code-comment"># Unit test example using pytest</span>
<span class="code-keyword">import</span> pytest
<span class="code-keyword">import</span> numpy <span class="code-keyword">as</span> np

<span class="code-comment"># Function to test</span>
<span class="code-keyword">def</span> normalize_vector(v):
    <span class="code-string">"""Normalize vector to unit length"""</span>
    magnitude = np.sqrt(np.sum(v**<span class="code-number">2</span>))
    <span class="code-keyword">if</span> magnitude == <span class="code-number">0</span>:
        <span class="code-keyword">return</span> v
    <span class="code-keyword">return</span> v / magnitude

<span class="code-comment"># Test: normal case</span>
<span class="code-keyword">def</span> test_normalize_vector():
    v = np.array([<span class="code-number">3</span>, <span class="code-number">4</span>])
    result = normalize_vector(v)
    <span class="code-comment"># Magnitude of [3, 4] is 5, so normalized is [0.6, 0.8]</span>
    expected = np.array([<span class="code-number">0.6</span>, <span class="code-number">0.8</span>])
    np.testing.assert_array_almost_equal(result, expected)

<span class="code-comment"># Test: zero vector edge case</span>
<span class="code-keyword">def</span> test_normalize_zero_vector():
    v = np.array([<span class="code-number">0</span>, <span class="code-number">0</span>])
    result = normalize_vector(v)
    <span class="code-comment"># Zero vector should return unchanged</span>
    np.testing.assert_array_equal(result, v)

<span class="code-comment"># Test: negative numbers</span>
<span class="code-keyword">def</span> test_normalize_negative_values():
    v = np.array([-<span class="code-number">1</span>, <span class="code-number">1</span>])
    result = normalize_vector(v)
    expected = np.array([-<span class="code-number">1</span>/np.sqrt(<span class="code-number">2</span>), <span class="code-number">1</span>/np.sqrt(<span class="code-number">2</span>)])
    np.testing.assert_array_almost_equal(result, expected)

<span class="code-comment"># Run tests: pytest test_example.py</span>
      </code-block>

      <div class="comparison-box">
        <div class="comparison-card" style="--comp-color: var(--green);">
          <div class="comp-title">With Tests</div>
          <div class="comp-content">You commit code. Tests run automatically. If you break something, tests fail immediately and you know exactly what's wrong. You fix it before it reaches production. You deploy with confidence.</div>
        </div>
        <div class="comparison-card" style="--comp-color: var(--hot);">
          <div class="comp-title">Without Tests</div>
          <div class="comp-content">You commit code and hope it works. You deploy to production. Users discover bugs. You scramble to fix issues in production. A bug in preprocessing silently corrupts model training but you don't notice until model performance drops weeks later.</div>
        </div>
      </div>

      <div class="impact-box">
        <div class="impact-grid">
          <div class="impact-item" style="--impact-color: var(--cool);">
            <div class="impact-item-title">üéØ Where It's Used</div>
            <div class="impact-item-content">Professional codebases have test coverage. PyTorch and TensorFlow have extensive test suites. Kaggle competitions and research code increasingly include tests. Production systems require tests before deployment. Testing is how you move from hacks to systems.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--green);">
            <div class="impact-item-title">üí° Why It Matters</div>
            <div class="impact-item-content">In machine learning, bugs are insidious. The model runs without errors but produces wrong predictions. Tests verify not just that code runs, but that it produces correct results. A test verifying data preprocessing maintains value ranges will catch silent corruption.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--accent);">
            <div class="impact-item-title">‚è±Ô∏è When You Need It</div>
            <div class="impact-item-content">Always. Every function should have tests. Test data loading, preprocessing, model code. The earlier you start testing, the fewer bugs reach production. Tests also serve as documentation of intended behavior.</div>
          </div>
        </div>
      </div>
    </div>

  </section>

  <!-- CODE ORGANIZATION -->
  <section id="organization">
    <div class="section-label">Structure and Readability</div>
    <h2 class="section-title">Code Organization and Quality</h2>

    <div class="practice-card" style="--practice-color: var(--accent);">
      <div class="practice-header">
        <div class="practice-icon">üìÅ</div>
        <div class="practice-title-section">
          <h2>Modularity and Clean Code</h2>
          <div class="practice-subtitle">Organize code logically, write for humans first</div>
        </div>
      </div>

      <div class="practice-body">
        Code is read far more often than it is written. You write a function once, but many people read it many times over its lifetime. Clean code prioritizes readability for those readers. This means meaningful names for variables and functions, clear logic flow, appropriate length, and strong documentation.

        Modularity means breaking code into logical pieces. A monolithic 1000-line file is overwhelming. Ten small, focused functions are understandable. Each function should do one thing well. Each module should have a clear purpose. This organization makes code easier to understand, test, debug, and modify.

        PEP 8 is Python's style guide. It specifies conventions like indentation (4 spaces), line length (79 characters), naming conventions (lowercase with underscores), spacing around operators. Following PEP 8 doesn't make code functionally better, but it makes it immediately recognizable to any Python developer. Consistency matters because your brain recognizes patterns. Inconsistent code requires constant context-switching.

        Documentation should explain the why, not the what. If code does something obvious, comments aren't needed. If code does something subtle or non-obvious, document it. Docstrings explain what functions do, what parameters they take, what they return. These docstrings appear in IDEs, making them easily accessible.
      </div>

      <div class="teaching-box">
        Imagine reading code written five years ago by someone who isn't here to explain it. Meaningful names, clear structure, and good documentation make this possible. Clean code is an act of respect for future readers. It shows you care about the people who will maintain this code months or years later.
      </div>

      <div class="code-block">
<span class="code-comment"># BAD: Unclear names, unclear purpose</span>
<span class="code-keyword">def</span> process(data):
    x = data.split(<span class="code-string">','</span>)
    y = []
    <span class="code-keyword">for</span> i <span class="code-keyword">in</span> x:
        z = float(i) * 1.8 + 32
        y.append(z)
    <span class="code-keyword">return</span> y

<span class="code-comment"># GOOD: Clear names, clear purpose, documentation</span>
<span class="code-keyword">def</span> celsius_to_fahrenheit_batch(csv_temperatures):
    <span class="code-string">"""
    Convert CSV-formatted Celsius temperatures to Fahrenheit.
    
    Args:
        csv_temperatures: String of comma-separated Celsius values
        
    Returns:
        List of temperatures in Fahrenheit
        
    Example:
        >>> celsius_to_fahrenheit_batch('0,20,100')
        [32.0, 68.0, 212.0]
    """</span>
    celsius_values = csv_temperatures.split(<span class="code-string">','</span>)
    fahrenheit_values = []
    
    <span class="code-keyword">for</span> celsius_str <span class="code-keyword">in</span> celsius_values:
        celsius = float(celsius_str)
        fahrenheit = celsius * <span class="code-number">1.8</span> + <span class="code-number">32</span>
        fahrenheit_values.append(fahrenheit)
    
    <span class="code-keyword">return</span> fahrenheit_values

<span class="code-comment"># Even better: concise and clear</span>
<span class="code-keyword">def</span> celsius_to_fahrenheit_batch(csv_temperatures):
    <span class="code-string">"""Convert comma-separated Celsius values to Fahrenheit list."""</span>
    celsius_values = [float(c) <span class="code-keyword">for</span> c <span class="code-keyword">in</span> csv_temperatures.split(<span class="code-string">','</span>)]
    <span class="code-keyword">return</span> [c * <span class="code-number">1.8</span> + <span class="code-number">32</span> <span class="code-keyword">for</span> c <span class="code-keyword">in</span> celsius_values]
      </code-block>

      <div class="best-practices">
        <div class="practices-title">Code Quality Practices</div>
        <div class="practice-list">
          <div class="practice-item">
            <div class="practice-item-title">Meaningful Names</div>
            <div class="practice-item-desc">Use names that explain purpose. normalize_features is better than nf. It takes slightly longer to type but saves minutes in future understanding.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Short Functions</div>
            <div class="practice-item-desc">Functions should do one thing. If a function needs multiple pages to explain, it's doing too much. Break it into smaller functions.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Consistent Style</div>
            <div class="practice-item-desc">Follow PEP 8. Use tools like Black to auto-format. Consistency reduces cognitive load‚Äîyour brain recognizes the patterns.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">DRY Principle</div>
            <div class="practice-item-desc">Don't Repeat Yourself. If code appears twice, extract it into a function. Reduces bugs and makes changes easier.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Error Handling</div>
            <div class="practice-item-desc">Anticipate what could go wrong. Raise meaningful errors with clear messages. This helps users understand what they did wrong.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Type Hints</div>
            <div class="practice-item-desc">Annotate function signatures with types. IDEs use this for autocomplete. Makes code self-documenting.</div>
          </div>
        </div>
      </div>

      <div class="impact-box">
        <div class="impact-grid">
          <div class="impact-item" style="--impact-color: var(--accent);">
            <div class="impact-item-title">üéØ Where It's Used</div>
            <div class="impact-item-content">Production code requires readability. Repositories get code reviews where readability matters. Open source projects have style guides enforced by automated tools. Professional teams won't merge code that doesn't follow standards.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--green);">
            <div class="impact-item-title">üí° Why It Matters</div>
            <div class="impact-item-content">Clean code is maintainable code. Bug fixes are faster. New features are easier to add. Onboarding new team members is quicker. The small effort to write clean code pays back in saved debugging time within weeks.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--warm);">
            <div class="impact-item-title">‚è±Ô∏è When You Need It</div>
            <div class="impact-item-content">Always. From the first lines of code. Building good habits from the start is easier than breaking bad habits later. Code reviews enforce standards, but better to write clean code initially.</div>
          </div>
        </div>
      </div>
    </div>

  </section>

  <!-- DEPLOYMENT AND CI -->
  <section id="deployment">
    <div class="section-label">Automation and Production</div>
    <h2 class="section-title">Continuous Integration and Deployment</h2>

    <div class="practice-card" style="--practice-color: var(--warm);">
      <div class="practice-header">
        <div class="practice-icon">‚öôÔ∏è</div>
        <div class="practice-title-section">
          <h2>Continuous Integration and Environment Management</h2>
          <div class="practice-subtitle">Automate testing, manage dependencies, enable reliable deployment</div>
        </div>
      </div>

      <div class="practice-body">
        Continuous Integration (CI) means automatically running tests and checks whenever code is pushed. You commit code, CI systems immediately run your tests, check style compliance, build the project. If anything fails, you're notified instantly. You fix the issue while it's fresh. This prevents broken code from accumulating in the main branch.

        Virtual environments solve a crucial problem: dependencies. Your machine learning project uses NumPy, Pandas, Scikit-learn, and PyTorch. Your colleague's project uses the same libraries but different versions. Running both projects on the same machine causes conflicts. Virtual environments isolate dependencies. Each project has its own environment with specific versions pinned.

        A requirements.txt file or environment.yml specifies all dependencies and versions. Someone else can recreate your exact environment by installing from this file. This reproducibility is essential in science and production. If your model gets deployed and later someone needs to debug why predictions changed, they can recreate the exact environment where training happened.

        Deployment takes your code to production where it serves real users. This requires coordination. You might deploy to staging (a test production environment) to verify everything works before deploying to production proper. You need monitoring to catch when things fail. Deployment automation lets you deploy quickly and consistently, reducing human error.
      </div>

      <div class="teaching-box">
        Think of CI as an automated quality control checkpoint. Every commit is verified before it reaches the main branch. This catches issues early when they're cheapest to fix. Virtual environments let code travel safely‚Äîyour exact setup is reproducible on any machine. Deployment automation means reliable, repeatable releases rather than error-prone manual procedures.
      </div>

      <div class="code-block">
<span class="code-comment"># requirements.txt: Pin exact versions</span>
numpy==1.24.3
pandas==2.0.2
scikit-learn==1.2.2
torch==2.0.1
matplotlib==3.7.1

<span class="code-comment"># Virtual environment workflow</span>
<span class="code-comment"># Create virtual environment</span>
python -m venv venv

<span class="code-comment"># Activate it</span>
source venv/bin/activate              <span class="code-comment"># On Mac/Linux</span>
<span class="code-comment"># venv\Scripts\activate            # On Windows</span>

<span class="code-comment"># Install dependencies</span>
pip install -r requirements.txt

<span class="code-comment"># When you add a new library, update requirements</span>
pip install new_library
pip freeze > requirements.txt

<span class="code-comment"># .github/workflows/ci.yml: GitHub Actions CI config</span>
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-python@v2
        with:
          python-version: 3.9
      - name: Install dependencies
        run: |
          python -m pip install -r requirements.txt
          pip install pytest
      - name: Run tests
        run: pytest
      - name: Check style
        run: |
          pip install flake8
          flake8 src/
      </code-block>

      <div class="comparison-box">
        <div class="comparison-card" style="--comp-color: var(--green);">
          <div class="comp-title">With CI and Virtual Environments</div>
          <div class="comp-content">You commit code. CI runs tests, linting, builds. Passes? Your PR can be merged safely. Dependencies are pinned. Anyone can run your code identically. Deployment is automated and reliable.</div>
        </div>
        <div class="comparison-card" style="--comp-color: var(--hot);">
          <div class="comp-title">Without CI and Virtual Environments</div>
          <div class="comp-content">You commit code and hope tests pass. Teammate can't run your code because library versions conflict. Manual deployment has typos. Someone changes a library version and breaks everyone's code. Tests aren't run automatically.</div>
        </div>
      </div>

      <div class="impact-box">
        <div class="impact-grid">
          <div class="impact-item" style="--impact-color: var(--warm);">
            <div class="impact-item-title">üéØ Where It's Used</div>
            <div class="impact-item-content">Every serious project uses CI/CD. GitHub, GitLab, and Bitbucket provide free CI for public repositories. Virtual environments are standard practice. Anyone working on teams or with production code uses these tools. They're not optional.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--cool);">
            <div class="impact-item-title">üí° Why It Matters</div>
            <div class="impact-item-content">CI catches bugs before they reach production. Virtual environments prevent "works on my machine" disasters. Automated deployment prevents human error in production. These practices reduce stress and enable confident shipping of code.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--accent);">
            <div class="impact-item-title">‚è±Ô∏è When You Need It</div>
            <div class="impact-item-content">From the start. Set up CI for your first project. Use virtual environments immediately. These tools are easier to set up early than to retrofit later. They have zero downside and huge upside.</div>
          </div>
        </div>
      </div>
    </div>

  </section>

  <!-- DEBUGGING -->
  <section>
    <div class="section-label">Problem Solving</div>
    <h2 class="section-title">Debugging and Understanding Failures</h2>

    <div class="practice-card" style="--practice-color: var(--hot);">
      <div class="practice-header">
        <div class="practice-icon">üêõ</div>
        <div class="practice-title-section">
          <h2>Systematic Debugging Strategies</h2>
          <div class="practice-subtitle">Find and fix bugs efficiently using systematic approaches</div>
        </div>
      </div>

      <div class="practice-body">
        Debugging is finding and fixing bugs. A bug is code behaving unexpectedly. Sometimes code crashes with an error message. Sometimes it runs without error but produces wrong results. The worst bugs don't fail noticeably but produce silently incorrect predictions.

        Systematic debugging starts with understanding the failure. What exactly is wrong? What did you expect? What happened instead? Run code step by step, examining state at each step. Python's debugger (pdb) lets you pause code execution, inspect variables, step through execution. Use print statements as a low-tech alternative, printing values to see state evolution.

        When debugging in machine learning, the issue is often silent failure. Model trains without error but produces bad predictions. Check data: Are values in expected ranges? Are any missing values? Do shapes match expectations? Are statistics reasonable? Often 90 percent of bugs are in data preprocessing, not the model. This is why tests for preprocessing are essential.

        Another debugging strategy is binary search. If the problem appears somewhere in your pipeline, split the pipeline in half. Does the problem appear in the first half? If yes, keep that half and split again. If no, the problem is in the second half. This rapidly narrows down problematic code.
      </div>

      <div class="teaching-box">
        Debugging is detective work. You're gathering evidence about what went wrong and where. Systematic approaches beat flailing. Form hypotheses and test them. Examine data carefully. Use tools to inspect state. Document what you learn so you don't debug the same issue twice. Over time, you'll recognize patterns and debug faster.
      </div>

      <div class="code-block">
<span class="code-comment"># Using Python debugger (pdb)</span>
<span class="code-keyword">import</span> pdb

<span class="code-keyword">def</span> preprocess_data(raw_data):
    <span class="code-comment"># Pause here to inspect</span>
    pdb.set_trace()
    
    normalized = (raw_data - raw_data.mean()) / raw_data.std()
    <span class="code-keyword">return</span> normalized

<span class="code-comment"># In debugger, you can:</span>
<span class="code-comment"># p normalized          - print variable value</span>
<span class="code-comment"># n                     - next line (step over)</span>
<span class="code-comment"># s                     - step into (enter function)</span>
<span class="code-comment"># c                     - continue execution</span>
<span class="code-comment"># h                     - help on commands</span>

<span class="code-comment"># Using print statements for debugging</span>
<span class="code-keyword">def</span> normalize_data(data):
    <span class="code-function">print</span>(<span class="code-string">f"Input shape: {data.shape}"</span>)
    <span class="code-function">print</span>(<span class="code-string">f"Input mean: {data.mean()}, std: {data.std()}"</span>)
    
    normalized = (data - data.mean()) / data.std()
    
    <span class="code-function">print</span>(<span class="code-string">f"Output shape: {normalized.shape}"</span>)
    <span class="code-function">print</span>(<span class="code-string">f"Output mean: {normalized.mean()}, std: {normalized.std()}"</span>)
    <span class="code-comment"># Check output is as expected</span>
    
    <span class="code-keyword">return</span> normalized

<span class="code-comment"># Binary search debugging approach</span>
<span class="code-comment"># 1. Load data -> produce prediction (something wrong)</span>
<span class="code-comment"># 2. Check data loading (is data reasonable?) -> yes</span>
<span class="code-comment"># 3. Check preprocessing (is preprocessed data reasonable?) -> no! bug found</span>
<span class="code-comment"># 4. Debug preprocessing functions in isolation</span>
      </code-block>

      <div class="best-practices">
        <div class="practices-title">Debugging Best Practices</div>
        <div class="practice-list">
          <div class="practice-item">
            <div class="practice-item-title">Reproduce Reliably</div>
            <div class="practice-item-desc">Get a minimal, reproducible case. Don't debug against the full dataset. Create a small example that shows the bug.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Examine Data Carefully</div>
            <div class="practice-item-desc">In machine learning, data is usually the issue. Check shapes, ranges, missing values, distributions. Data bugs are silent.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Verify Assumptions</div>
            <div class="practice-item-desc">You assume data has certain properties. Verify this. Add assertions that document assumptions and fail if violated.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Isolate Components</div>
            <div class="practice-item-desc">Test components independently. Does preprocessing work? Does the model work on synthetic data? Isolate where the issue lies.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Use Version Control</div>
            <div class="practice-item-desc">If something worked yesterday and doesn't today, use Git to see what changed. This immediately points to the problem area.</div>
          </div>
          <div class="practice-item">
            <div class="practice-item-title">Document Solutions</div>
            <div class="practice-item-desc">When you solve a bug, document what was wrong and why. This prevents debugging the same issue twice.</div>
          </div>
        </div>
      </div>

      <div class="impact-box">
        <div class="impact-grid">
          <div class="impact-item" style="--impact-color: var(--hot);">
            <div class="impact-item-title">üéØ Where It's Used</div>
            <div class="impact-item-content">Every development session involves some debugging. Machine learning especially because silent failures are common. Professionals spend significant time debugging‚Äîit's a core skill, not a weakness.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--accent);">
            <div class="impact-item-title">üí° Why It Matters</div>
            <div class="impact-item-content">Debugging skill separates frustrated developers from productive ones. Systematic approaches beat flailing. Understanding debugging deeply makes you faster and less stressed. Most development time is debugging, not initial coding.</div>
          </div>
          <div class="impact-item" style="--impact-color: var(--cool);">
            <div class="impact-item-title">‚è±Ô∏è When You Need It</div>
            <div class="impact-item-content">Constantly. As you develop, things break. Tests catch some breaks early. Others you discover when deployed. Debugging skill determines how quickly you fix issues. Invest in learning tools and strategies.</div>
          </div>
        </div>
      </div>
    </div>

  </section>

  <!-- COMPLETE WORKFLOW -->
  <section>
    <div class="section-label">The Complete Picture</div>
    <h2 class="section-title">Professional Development Workflow</h2>

    <div class="timeline">
      <div class="timeline-item">
        <div class="timeline-title">Initialize Project with Git</div>
        <div class="timeline-desc">Create a Git repository immediately. Add a .gitignore file to exclude virtual environments and large files. Set up for collaboration from the start.</div>
      </div>

      <div class="timeline-item">
        <div class="timeline-title">Create Virtual Environment</div>
        <div class="timeline-desc">Isolate dependencies for this project. Install needed libraries. Pin versions in requirements.txt. Ensure reproducibility.</div>
      </div>

      <div class="timeline-item">
        <div class="timeline-title">Set Up CI/CD</div>
        <div class="timeline-desc">Configure GitHub Actions or similar. Specify test runs and style checks. Automate quality control.</div>
      </div>

      <div class="timeline-item">
        <div class="timeline-title">Write Code with Tests</div>
        <div class="timeline-desc">Write test first or alongside code. Tests document expected behavior. They catch regressions automatically.</div>
      </div>

      <div class="timeline-item">
        <div class="timeline-title">Organize Code Logically</div>
        <div class="timeline-desc">Structure code into modules with clear purposes. Follow PEP 8. Use meaningful names. Document non-obvious logic.</div>
      </div>

      <div class="timeline-item">
        <div class="timeline-title">Commit Frequently with Clear Messages</div>
        <div class="timeline-desc">Small, logical commits create readable history. Clear messages explain intent. History becomes valuable documentation.</div>
      </div>

      <div class="timeline-item">
        <div class="timeline-title">Create Pull Requests for Review</div>
        <div class="timeline-desc">Before merging to main, get code review. Teammates catch issues. Knowledge sharing happens. Code quality improves.</div>
      </div>

      <div class="timeline-item">
        <div class="timeline-title">Merge and Deploy Confidently</div>
        <div class="timeline-desc">CI passes. Tests pass. Code reviewed. Merge safely. Deploy knowing code is solid.</div>
      </div>

      <div class="timeline-item">
        <div class="timeline-title">Monitor and Debug Proactively</div>
        <div class="timeline-desc">Watch deployed code for issues. When problems arise, debug systematically. Document solutions. Improve continuously.</div>
      </div>
    </div>

  </section>

</div>

<!-- Footer -->
<footer>
  <p class="footer-text">Software Engineering Practices ‚Äî Building Professional Systems</p>
</footer>

</body>
</html>
