<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graph Concepts ‚Äî Understanding Networks and Relationships</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Mono:wght@400;500&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=Syne+Mono&display=swap');

:root {
  --bg: #04040a;
  --accent: #7b2fff;
  --hot: #ff2d78;
  --cool: #00e5ff;
  --warm: #ffb800;
  --green: #00ff9d;
  --text: #e0e0f0;
  --muted: #4a4a6a;
  --card: #0a0a14;
  --border: rgba(255,255,255,0.07);
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html { scroll-behavior: smooth; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Syne', sans-serif;
  overflow-x: hidden;
  line-height: 1.8;
}

body::before {
  content: '';
  position: fixed; inset: 0; z-index: 0;
  background:
    radial-gradient(ellipse 100% 60% at 50% 0%, rgba(123,47,255,0.12) 0%, transparent 60%),
    radial-gradient(ellipse 60% 40% at 0% 100%, rgba(0,229,255,0.06) 0%, transparent 60%);
  pointer-events: none;
}

.wrap { position: relative; z-index: 1; max-width: 1100px; margin: 0 auto; padding: 0 28px; }

nav {
  position: sticky; top: 0; z-index: 100;
  background: rgba(4,4,10,0.9);
  backdrop-filter: blur(24px);
  border-bottom: 1px solid var(--border);
  padding: 14px 28px;
  display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
}
.nav-brand { font-family: 'Bebas Neue', sans-serif; font-size: 20px; color: var(--accent); margin-right: auto; letter-spacing: 2px; }
.nav-pill {
  font-family: 'Syne Mono', monospace; font-size: 10px; letter-spacing: 2px;
  padding: 5px 12px; border-radius: 20px; border: 1px solid rgba(123,47,255,0.4);
  color: rgba(123,47,255,0.8); text-decoration: none; transition: all 0.2s;
}
.nav-pill:hover { background: rgba(123,47,255,0.15); border-color: var(--accent); color: #fff; }

.hero { padding: 90px 0 50px; }
.hero-eyebrow {
  font-family: 'Syne Mono', monospace; font-size: 11px; letter-spacing: 4px;
  color: var(--accent); text-transform: uppercase; margin-bottom: 18px;
  display: flex; align-items: center; gap: 12px;
}
.hero-eyebrow::after { content: ''; flex: 1; height: 1px; background: rgba(123,47,255,0.3); }

.hero h1 {
  font-family: 'Bebas Neue', sans-serif;
  font-size: clamp(48px, 10vw, 100px);
  line-height: 0.92; margin-bottom: 28px;
  color: #fff;
}

.hero-desc { max-width: 750px; font-size: 16px; color: rgba(210,210,240,0.72); line-height: 1.8; margin-bottom: 40px; }

section { padding: 70px 0; border-top: 1px solid var(--border); }
.section-label { font-family: 'Syne Mono', monospace; font-size: 10px; letter-spacing: 4px; color: var(--accent); text-transform: uppercase; margin-bottom: 16px; }
.section-title { font-family: 'Bebas Neue', sans-serif; font-size: clamp(36px, 6vw, 64px); line-height: 1; margin-bottom: 40px; color: #fff; }

.concept-card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 40px;
  margin-bottom: 36px;
  border-left: 4px solid var(--card-accent, var(--accent));
  transition: all 0.3s;
}

.concept-card:hover {
  border-color: var(--card-accent, var(--accent));
  background: linear-gradient(135deg, rgba(255,255,255,0.02) 0%, transparent 100%);
  transform: translateY(-2px);
}

.concept-title {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 28px;
  color: var(--card-accent, var(--accent));
  margin-bottom: 20px;
  letter-spacing: 1px;
}

.concept-body {
  font-size: 15px;
  color: rgba(210,210,240,0.88);
  line-height: 1.9;
  margin-bottom: 28px;
}

.concept-body p {
  margin-bottom: 18px;
}

.concept-body strong {
  color: #fff;
}

.code-block {
  background: rgba(0,0,0,0.5);
  border: 1px solid rgba(0,229,255,0.2);
  border-radius: 12px;
  padding: 24px;
  margin: 28px 0;
  font-family: 'DM Mono', monospace;
  font-size: 13px;
  color: #fff;
  overflow-x: auto;
  line-height: 1.6;
}

.code-comment { color: #5c7a8a; }
.code-keyword { color: var(--accent); }
.code-string { color: var(--green); }
.code-number { color: var(--warm); }
.code-function { color: var(--cool); }

.teaching-box {
  background: rgba(123,47,255,0.1);
  border-left: 4px solid var(--accent);
  padding: 24px;
  border-radius: 10px;
  margin: 28px 0;
  font-size: 15px;
  color: rgba(210,210,240,0.9);
  line-height: 1.8;
}

.teaching-box strong {
  color: #fff;
}

.impact-box {
  background: linear-gradient(135deg, rgba(123,47,255,0.15) 0%, rgba(0,229,255,0.08) 100%);
  border: 1px solid rgba(123,47,255,0.3);
  border-radius: 14px;
  padding: 32px;
  margin-top: 32px;
}

.impact-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 28px;
}

.impact-item {
  padding: 24px;
  background: rgba(0,0,0,0.2);
  border-radius: 10px;
  border-left: 4px solid var(--impact-color, var(--accent));
}

.impact-item-title {
  font-family: 'Syne Mono', monospace;
  font-size: 12px;
  letter-spacing: 2px;
  color: var(--impact-color, var(--accent));
  text-transform: uppercase;
  margin-bottom: 14px;
  font-weight: 600;
}

.impact-item-content {
  font-size: 13px;
  color: rgba(200,200,220,0.88);
  line-height: 1.8;
}

.insight-box {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 32px;
  margin: 28px 0;
  border-left: 4px solid var(--insight-color, var(--accent));
}

.insight-title {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 20px;
  color: var(--insight-color, var(--accent));
  margin-bottom: 16px;
  letter-spacing: 1px;
}

.insight-content {
  font-size: 15px;
  color: rgba(210,210,240,0.88);
  line-height: 1.8;
}

footer {
  padding: 60px 0 40px;
  border-top: 1px solid var(--border);
  text-align: center;
}

.footer-text {
  font-family: 'Syne Mono', monospace;
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--muted);
  text-transform: uppercase;
}

@media (max-width: 768px) {
  .hero { padding: 60px 0 40px; }
  section { padding: 50px 0; }
  .impact-grid { grid-template-columns: 1fr; }
}
</style>
</head>
<body>

<nav>
  <div class="nav-brand">GRAPH CONCEPTS</div>
  <a href="#fundamentals" class="nav-pill">Fundamentals</a>
  <a href="#types" class="nav-pill">Types</a>
  <a href="#representations" class="nav-pill">Representations</a>
</nav>

<div class="wrap">

  <section class="hero">
    <div class="hero-eyebrow">Understanding Networks and Relationships</div>
    <h1>Graph Concepts: The Language of Networks and Connections</h1>
    <p class="hero-desc">Graphs are one of the most fundamental data structures in mathematics and computer science, yet they're often introduced in ways that make them seem abstract and disconnected from real applications. In reality, graphs are everywhere. Your brain is a network of neurons connected by synapses. Social networks connect people through friendships. The internet connects computers through routing relationships. Recommendation systems connect users to products through ratings and purchases. Chemical molecules are networks of atoms connected by bonds. Transportation systems connect locations through roads and routes. The power grid connects generators, transformers, and consumers through electrical lines. Understanding graphs deeply means understanding how to model the world's relationships and connections mathematically. It means being able to represent networks efficiently, analyze their properties, and eventually apply algorithms to answer questions about them. This section teaches you the foundational concepts of graphs, starting from the simplest ideas of nodes and edges, building through different graph types with their distinct properties, and exploring how to represent graphs computationally so you can work with them in code. By the end, you'll understand not just the mathematical definitions but the intuitions behind why different graph types matter and how to choose appropriate representations for different problems. You'll see that graphs aren't abstract mathematics but a powerful language for describing the world's most important relationships and structures.</p>
  </section>

  <section id="fundamentals">
    <div class="section-label">Understanding Basic Building Blocks</div>
    <h2 class="section-title">Graph Fundamentals: Nodes, Edges, and Connections</h2>

    <div class="concept-card" style="--card-accent: var(--cool);">
      <div class="concept-title">üîó Nodes and Edges: The Minimal Elements of Graphs</div>
      <div class="concept-body">
        <p>Let me start with the simplest possible explanation of what a graph is. A graph is a collection of objects called nodes (sometimes called vertices) and connections between them called edges. That's truly all you need to define a graph. The nodes represent things: people, locations, concepts, atoms, computer systems, whatever you're trying to model. The edges represent relationships between those things: friendships between people, roads between locations, logical connections between concepts, bonds between atoms, network connections between computers. Every graph you'll encounter, no matter how complex, reduces to these two simple elements.</p>

        <p>To make this concrete, let me give you a familiar example. In a social network like Facebook, each person is a node. The friendships between people are edges. If Alice is friends with Bob, there's an edge connecting the Alice node to the Bob node. If Bob is also friends with Charlie, there's another edge connecting Bob's node to Charlie's node. The graph of a small social network might look like this conceptually: three nodes labeled Alice, Bob, and Charlie, with edges connecting Alice to Bob and Bob to Charlie. This simple structure captures the essential information about friendships without getting bogged down in details about what those people like, what they do, or anything else besides their connections.</p>

        <p>Why is this abstraction useful? Because once you abstract away the specific nature of nodes and edges, the same algorithms and analysis techniques apply to very different problems. An algorithm that finds the shortest path between two nodes works whether you're routing messages between computers or finding the shortest route for a delivery person. An algorithm that identifies communities in a graph works whether you're finding groups of friends in a social network or discovering functional modules in a protein network. The abstraction enables reuse of insights and techniques across domains.</p>

        <p>One important distinction at the very beginning: nodes and edges are the essential elements of graphs, but a graph is not just a collection of isolated nodes and edges. The crucial part is how they're connected. A graph of twenty nodes with no edges is very different from a graph of twenty nodes where each node is connected to every other node. The structure of connections is what gives a graph its interesting properties and what algorithms operate on. When we talk about analyzing a graph, we're really analyzing the structure of how its nodes are connected through edges.</p>
      </div>

      <div class="teaching-box">
        <p>Think of a graph like a map of a city. The nodes are the intersections and landmarks. The edges are the streets connecting them. The value of the map isn't just knowing where intersections exist. It's understanding which intersections are connected by streets, which streets are short, which intersections are far from others, which neighborhoods cluster together. The structure of connections is what makes the map useful. Graphs work the same way. The structure of how nodes connect through edges is what makes graphs useful for answering questions about the world.</p>
      </div>
    </div>

    <div class="concept-card" style="--card-accent: var(--warm);">
      <div class="concept-title">üìä Node and Edge Features: Adding Rich Information to Graphs</div>
      <div class="concept-body">
        <p>The most basic graphs just have nodes and edges, with no additional information beyond which nodes are connected. But real graphs almost always have additional information. A person node in a social network might have features like their name, location, interests, join date, and the number of followers. A location node in a transportation network might have features like coordinates, elevation, and population. These are node features, information attached to individual nodes that describes their properties.</p>

        <p>Similarly, edges often have features too. In a transportation network, an edge between two locations represents a road that might have properties like distance, speed limit, number of lanes, and current traffic conditions. In a citation network where papers are nodes and citation relationships are edges, an edge might have features indicating what the citing paper said about the cited work. These are edge features, information attached to edges that describes the nature or properties of the connection.</p>

        <p>Features transform graphs from abstract structure to rich, meaningful representations of reality. Without features, you know which nodes are connected but not much about what those nodes represent or what the connections mean. With features, graphs become powerful data structures that can represent complex information. For example, in a molecular graph where atoms are nodes and bonds are edges, node features might include the atomic number and formal charge, while edge features might include the bond type (single, double, triple bond). These features enable analyzing chemical properties based on the graph structure.</p>

        <p>One practical consideration: features can be numerical (like distances or counts), categorical (like colors or types), or more complex (like text descriptions or vectors). Different representations are appropriate for different feature types. Numerical features might be stored as floats, categorical features as integers representing categories, and complex features as separate data structures. The graph itself specifies the structure of connections, while features specify properties of the things being connected.</p>
      </div>

      <div class="teaching-box">
        <p>Imagine describing a social network to someone who has never seen social networks. Saying "Alice is connected to Bob" gives minimal information. Saying "Alice, a 25-year-old software engineer in San Francisco who loves hiking, is connected to Bob, a 28-year-old designer in New York who loves photography" gives much richer understanding of who these people are and what the connection might mean. Node and edge features provide this richness. They transform graphs from abstract connection patterns into representations that capture the complexity of real-world relationships and properties.</p>
      </div>

      <div class="code-block">
<span class="code-comment"># Understanding graphs with nodes, edges, and features</span>

<span class="code-keyword">class</span> <span class="code-function">SimpleGraph</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-keyword">self</span>):
        <span class="code-comment"># Nodes and edges are the core of any graph</span>
        <span class="code-keyword">self</span>.nodes = {}  <span class="code-comment"># Dictionary to store nodes and their features</span>
        <span class="code-keyword">self</span>.edges = []  <span class="code-comment"># List to store edges and their features</span>
    
    <span class="code-keyword">def</span> <span class="code-function">add_node</span>(<span class="code-keyword">self</span>, node_id, features=<span class="code-keyword">None</span>):
        <span class="code-comment"># Add a node to the graph with optional features</span>
        <span class="code-comment"># Features could be anything: a dictionary, a vector, metadata</span>
        <span class="code-keyword">self</span>.nodes[node_id] = features <span class="code-keyword">or</span> {}
    
    <span class="code-keyword">def</span> <span class="code-function">add_edge</span>(<span class="code-keyword">self</span>, node_a, node_b, features=<span class="code-keyword">None</span>):
        <span class="code-comment"># Add an edge between two nodes with optional features</span>
        <span class="code-comment"># The edge connects node_a to node_b</span>
        edge = {
            <span class="code-string">'from'</span>: node_a,
            <span class="code-string">'to'</span>: node_b,
            <span class="code-string">'features'</span>: features <span class="code-keyword">or</span> {}
        }
        <span class="code-keyword">self</span>.edges.append(edge)

<span class="code-comment"># Example: Social network graph</span>
graph = SimpleGraph()

<span class="code-comment"># Add nodes with features (person information)</span>
graph.add_node(<span class="code-string">'alice'</span>, {<span class="code-string">'name'</span>: <span class="code-string">'Alice'</span>, <span class="code-string">'age'</span>: <span class="code-number">25</span>, <span class="code-string">'city'</span>: <span class="code-string">'SF'</span>})
graph.add_node(<span class="code-string">'bob'</span>, {<span class="code-string">'name'</span>: <span class="code-string">'Bob'</span>, <span class="code-string">'age'</span>: <span class="code-number">28</span>, <span class="code-string">'city'</span>: <span class="code-string">'NYC'</span>})
graph.add_node(<span class="code-string">'charlie'</span>, {<span class="code-string">'name'</span>: <span class="code-string">'Charlie'</span>, <span class="code-string">'age'</span>: <span class="code-number">23</span>, <span class="code-string">'city'</span>: <span class="code-string">'SF'</span>})

<span class="code-comment"># Add edges with features (friendship information)</span>
graph.add_edge(<span class="code-string">'alice'</span>, <span class="code-string">'bob'</span>, {<span class="code-string">'since'</span>: <span class="code-number">2020</span>, <span class="code-string">'strength'</span>: <span class="code-string">'strong'</span>})
graph.add_edge(<span class="code-string">'bob'</span>, <span class="code-string">'charlie'</span>, {<span class="code-string">'since'</span>: <span class="code-number">2021</span>, <span class="code-string">'strength'</span>: <span class="code-string">'weak'</span>})
graph.add_edge(<span class="code-string">'alice'</span>, <span class="code-string">'charlie'</span>, {<span class="code-string">'since'</span>: <span class="code-number">2019</span>, <span class="code-string">'strength'</span>: <span class="code-string">'strong'</span>})

<span class="code-comment"># The graph now contains:</span>
<span class="code-comment"># - Three nodes representing people with their attributes</span>
<span class="code-comment"># - Three edges representing friendships with their attributes</span>
<span class="code-comment"># - This structure captures a social network with rich information</span>
      </code-block>
    </div>

  </section>

  <section id="types">
    <div class="section-label">Understanding Different Graph Structures</div>
    <h2 class="section-title">Graph Types: How Different Properties Create Different Graph Classes</h2>

    <div class="concept-card" style="--card-accent: var(--green);">
      <div class="concept-title">üîÄ Directed vs Undirected Graphs: The Direction of Relationships</div>
      <div class="concept-body">
        <p>One of the most fundamental distinctions in graphs is between directed and undirected graphs. In an undirected graph, edges have no inherent direction. If there's an edge connecting Alice to Bob, you can think of it as going either direction equally. This is natural for relationships that are symmetric, like friendship. If Alice is friends with Bob, then Bob is friends with Alice. The edge between them has no preferred direction. Similarly, roads connecting two cities (if we ignore one-way streets) are naturally undirected because you can travel in either direction.</p>

        <p>In a directed graph, edges have a specific direction indicated by an arrow. If there's a directed edge from Alice to Bob, it means the relationship goes from Alice toward Bob. This doesn't mean there's also an edge from Bob to Alice. Bob might have a separate edge going to Alice, but that's a different edge. Directed graphs naturally represent asymmetric relationships. If Alice follows Bob on Twitter, that's a directed edge from Alice to Bob. Bob might follow Alice back, but that's a separate relationship and a separate edge. Similarly, in a citation network, if paper A cites paper B, that's a directed edge from A to B. The citation doesn't naturally go the other direction.</p>

        <p>The practical difference is significant. In an undirected graph, finding neighbors (nodes directly connected) is straightforward: both people in a friendship are neighbors of each other. In a directed graph, you need to distinguish between incoming neighbors (nodes with edges pointing to you) and outgoing neighbors (nodes you point to). An undirected graph of a transportation network where both directions of travel are equally possible is different from a directed graph representing a one-way street network where you can only travel in specific directions.</p>

        <p>How do you decide whether a relationship is directed or undirected? Think about whether the relationship naturally has direction. Friendships are usually undirected: being friends is mutual. Following on social media is usually directed: you can follow someone without them following you back. Parent-child relationships are directed: your mother is your parent, but you're not your mother's parent. A good test is asking whether the relationship makes sense in reverse. If it does, the graph is probably undirected. If it only makes sense in one direction, the graph is probably directed.</p>
      </div>

      <div class="teaching-box">
        <p>Think about the difference between a telephone call and an email. A telephone call is inherently two-way communication, symmetric, like an undirected edge: if Alice calls Bob, then Alice and Bob are talking to each other. An email is one-way communication: Alice sends an email to Bob, but Bob receiving that email doesn't automatically mean Bob is emailing Alice back. Email naturally represents a directed relationship. This same distinction applies to graphs: some relationships are naturally symmetric and undirected, others are naturally asymmetric and directed.</p>
      </div>
    </div>

    <div class="concept-card" style="--card-accent: var(--hot);">
      <div class="concept-title">‚öñÔ∏è Weighted Graphs: Adding Numerical Properties to Edges</div>
      <div class="concept-body">
        <p>Many real-world graphs don't just have connections between nodes but different kinds of connections with varying strengths or costs. In a transportation network, different roads have different distances. In a social network, different friendships have different strength (you might be close friends with some people and acquaintances with others). In a communication network, different connections might have different bandwidth. Weighted graphs represent this by attaching numerical weights to edges. The weight typically represents some quantity like distance, cost, strength, capacity, or importance.</p>

        <p>Weights transform algorithms and analysis. In an unweighted graph, the shortest path between two nodes is simply the path with the fewest edges. In a weighted graph, the shortest path is the path where the sum of edge weights is minimized. These can be very different. Imagine routing a truck from City A to City B. The path with the fewest city transitions (fewest edges) might involve really long distances on some roads. The path minimizing total distance (minimizing the sum of weights) might involve more cities but shorter total distance. The weights change what "shortest" means.</p>

        <p>Weights can be positive, negative, or zero, though negative weights create special challenges for path-finding algorithms. Zero-weight edges represent cost-free connections. Negative-weight edges represent relationships with benefit, though they can create problems in algorithms that assume positive weights. In practice, most real-world graphs use positive weights representing quantities like distance, cost, or time.</p>

        <p>The difference between unweighted and weighted graphs is significant in practice. Unweighted graphs answer questions about connectivity and structure. Weighted graphs answer questions about optimal paths, flows, and costs. Most real-world applications use weighted graphs because relationships almost always have varying strengths or costs. The weights often contain the most important information about the relationships.</p>
      </div>

      <div class="teaching-box">
        <p>Think about a map with roads of different lengths. Without weights, you only know which towns are directly connected by roads, but not how far apart they are. With weights (distances), you can find the actual shortest route between towns. The weights don't change the graph's basic structure, but they completely change what questions you can answer and how you solve them. Many problems that seem unsolvable on an unweighted graph become solvable with weights that capture the real quantities you care about.</p>
      </div>
    </div>

  </section>

  <section id="representations">
    <div class="section-label">Working with Graphs Computationally</div>
    <h2 class="section-title">Graph Representations: Choosing How to Store and Access Graphs</h2>

    <div class="concept-card" style="--card-accent: var(--cool);">
      <div class="concept-title">üìã Adjacency Matrices: A Dense Graph Representation</div>
      <div class="concept-body">
        <p>An adjacency matrix is perhaps the most straightforward way to represent a graph computationally. For a graph with n nodes, you create an n by n matrix where entry (i,j) represents the connection between node i and node j. In an unweighted graph, entry (i,j) is one if there's an edge from i to j, and zero if there isn't. In a weighted graph, entry (i,j) contains the weight of the edge from i to j, or zero if there's no edge. This representation works equally well for directed and undirected graphs, though undirected graphs have the special property that the matrix is symmetric: entry (i,j) equals entry (j,i).</p>

        <p>The adjacency matrix representation makes certain operations very fast. Checking whether two nodes are connected is constant time: just look at the appropriate matrix entry. Adding or removing an edge is constant time. Finding all neighbors of a node takes linear time in the number of nodes: you scan the corresponding row of the matrix. These properties make adjacency matrices attractive for dense graphs where there are many connections between nodes.</p>

        <p>However, adjacency matrices have a significant downside for sparse graphs where most nodes aren't directly connected. A graph with one million nodes requires a one million by one million matrix with a trillion entries, most of which are zero. This is computationally wasteful in both memory and computation. For sparse graphs, you might spend most of your time processing irrelevant zeros. This is where alternative representations become important.</p>
      </div>

      <div class="teaching-box">
        <p>Think of an adjacency matrix like a seating chart where you record whether each pair of people is sitting next to each other. For a small party with ten people, a ten by ten table is manageable. But for a party with a thousand people, a thousand by thousand table is unwieldy, especially if most people aren't sitting next to most other people. You're using tremendous amounts of space to record that most pairs aren't adjacent. This is where the limitations of adjacency matrices become apparent for sparse graphs.</p>
      </div>

      <div class="code-block">
<span class="code-comment"># Understanding adjacency matrix representation</span>

<span class="code-keyword">import</span> numpy <span class="code-keyword">as</span> np

<span class="code-comment"># Create an adjacency matrix for a graph with 4 nodes</span>
<span class="code-comment"># We'll use 1 for edges, 0 for no edges</span>
adjacency_matrix = np.array([
    [<span class="code-number">0</span>, <span class="code-number">1</span>, <span class="code-number">1</span>, <span class="code-number">0</span>],  <span class="code-comment"># Node 0 connects to nodes 1 and 2</span>
    [<span class="code-number">1</span>, <span class="code-number">0</span>, <span class="code-number">0</span>, <span class="code-number">1</span>],  <span class="code-comment"># Node 1 connects to nodes 0 and 3</span>
    [<span class="code-number">1</span>, <span class="code-number">0</span>, <span class="code-number">0</span>, <span class="code-number">1</span>],  <span class="code-comment"># Node 2 connects to nodes 0 and 3</span>
    [<span class="code-number">0</span>, <span class="code-number">1</span>, <span class="code-number">1</span>, <span class="code-number">0</span>]   <span class="code-comment"># Node 3 connects to nodes 1 and 2</span>
])

<span class="code-comment"># For an undirected graph, the matrix is symmetric</span>
<span class="code-comment"># adjacency_matrix[i][j] == adjacency_matrix[j][i]</span>

<span class="code-comment"># Checking if nodes are connected: O(1) constant time</span>
<span class="code-keyword">if</span> adjacency_matrix[<span class="code-number">0</span>][<span class="code-number">1</span>] == <span class="code-number">1</span>:
    <span class="code-function">print</span>(<span class="code-string">"Node 0 connects to node 1"</span>)

<span class="code-comment"># Finding neighbors of a node: O(n) linear time</span>
node = <span class="code-number">0</span>
neighbors = [j <span class="code-keyword">for</span> j <span class="code-keyword">in</span> <span class="code-function">range</span>(<span class="code-number">4</span>) <span class="code-keyword">if</span> adjacency_matrix[node][j] == <span class="code-number">1</span>]
<span class="code-function">print</span>(<span class="code-string">f"Node {node} connects to: {neighbors}"</span>)

<span class="code-comment"># For weighted graphs, store weights instead of just 1s and 0s</span>
weighted_adjacency = np.array([
    [<span class="code-number">0</span>, <span class="code-number">5</span>, <span class="code-number">3</span>, <span class="code-number">0</span>],  <span class="code-comment"># Edge 0->1 has weight 5, 0->2 has weight 3</span>
    [<span class="code-number">5</span>, <span class="code-number">0</span>, <span class="code-number">0</span>, <span class="code-number">2</span>],  <span class="code-comment"># Edge 1->3 has weight 2</span>
    [<span class="code-number">3</span>, <span class="code-number">0</span>, <span class="code-number">0</span>, <span class="code-number">4</span>],
    [<span class="code-number">0</span>, <span class="code-number">2</span>, <span class="code-number">4</span>, <span class="code-number">0</span>]
])
      </code-block>
    </div>

    <div class="concept-card" style="--card-accent: var(--warm);">
      <div class="concept-title">üóÇÔ∏è Adjacency Lists: An Efficient Representation for Sparse Graphs</div>
      <div class="concept-body">
        <p>An adjacency list representation is more efficient for sparse graphs. Rather than storing a full matrix, you store for each node a list of the nodes it connects to. For a graph with n nodes and m edges, an adjacency list requires O(n+m) space, compared to O(n squared) for an adjacency matrix. For sparse graphs where m is much smaller than n squared, this is significantly more efficient.</p>

        <p>In an adjacency list, you might use a dictionary where keys are node identifiers and values are lists of neighboring nodes. To check if two nodes are connected, you look up the source node and scan its neighbor list. This is faster than O(n) when nodes have few neighbors, but slower than O(1) compared to matrix lookup. However, the space savings often make this tradeoff worthwhile. Finding all neighbors of a node is now O(degree of the node) where degree is the number of neighbors, which is optimal because you must examine each neighbor at least once.</p>

        <p>For weighted graphs, adjacency lists can store pairs of (neighbor, weight) rather than just neighbors. This preserves the space efficiency while capturing weight information. Adjacency lists naturally generalize to directed graphs: each node has an outgoing adjacency list. For undirected graphs, you might store edges twice: once in each endpoint's list, or you might explicitly represent undirected edges as pairs of directed edges.</p>

        <p>In practice, adjacency lists are the preferred representation for most applications involving large, sparse graphs. Social networks, web graphs, and road networks are typically sparse, making adjacency lists more efficient than dense adjacency matrices. The slightly slower connection-checking time is usually worth the significant space savings and better cache performance when iterating over neighbors.</p>
      </div>

      <div class="teaching-box">
        <p>Think of an adjacency list like a contact list where each person has a list of their friends. Rather than storing a table showing every pair of people and whether they're friends (which would be huge), you just store for each person the specific friends they have. This is much more efficient when most people don't know most other people. To find if two people are friends, you check if person B is in person A's friend list. To see all someone's friends, you look at their list. This is more practical than checking every single pair in a huge table.</p>
      </div>

      <div class="code-block">
<span class="code-comment"># Understanding adjacency list representation</span>

<span class="code-comment"># Adjacency list using a dictionary</span>
<span class="code-comment"># Keys are node identifiers, values are lists of neighbors</span>
adjacency_list = {
    <span class="code-number">0</span>: [<span class="code-number">1</span>, <span class="code-number">2</span>],      <span class="code-comment"># Node 0 connects to nodes 1 and 2</span>
    <span class="code-number">1</span>: [<span class="code-number">0</span>, <span class="code-number">3</span>],      <span class="code-comment"># Node 1 connects to nodes 0 and 3</span>
    <span class="code-number">2</span>: [<span class="code-number">0</span>, <span class="code-number">3</span>],      <span class="code-comment"># Node 2 connects to nodes 0 and 3</span>
    <span class="code-number">3</span>: [<span class="code-number">1</span>, <span class="code-number">2</span>]       <span class="code-comment"># Node 3 connects to nodes 1 and 2</span>
}

<span class="code-comment"># Finding neighbors of a node: O(degree) time</span>
node = <span class="code-number">0</span>
neighbors = adjacency_list[node]
<span class="code-function">print</span>(<span class="code-string">f"Node {node} connects to: {neighbors}"</span>)

<span class="code-comment"># Checking if nodes are connected: O(degree) time</span>
<span class="code-keyword">if</span> <span class="code-number">1</span> <span class="code-keyword">in</span> adjacency_list[<span class="code-number">0</span>]:
    <span class="code-function">print</span>(<span class="code-string">"Node 0 connects to node 1"</span>)

<span class="code-comment"># For weighted graphs, store (neighbor, weight) tuples</span>
weighted_adjacency_list = {
    <span class="code-number">0</span>: [(<span class="code-number">1</span>, <span class="code-number">5</span>), (<span class="code-number">2</span>, <span class="code-number">3</span>)],  <span class="code-comment"># Edges with weights</span>
    <span class="code-number">1</span>: [(<span class="code-number">0</span>, <span class="code-number">5</span>), (<span class="code-number">3</span>, <span class="code-number">2</span>)],
    <span class="code-number">2</span>: [(<span class="code-number">0</span>, <span class="code-number">3</span>), (<span class="code-number">3</span>, <span class="code-number">4</span>)],
    <span class="code-number">3</span>: [(<span class="code-number">1</span>, <span class="code-number">2</span>), (<span class="code-number">2</span>, <span class="code-number">4</span>)]
}

<span class="code-comment"># Adjacency lists are more memory-efficient for sparse graphs</span>
<span class="code-comment"># Space: O(n + m) vs O(n¬≤) for adjacency matrix</span>
      </code-block>
    </div>

    <div class="concept-card" style="--card-accent: var(--green);">
      <div class="concept-title">üìà Graph Properties and Statistics: Understanding Global Structure</div>
      <div class="concept-body">
        <p>Beyond local structure (individual nodes and edges), graphs have global properties that characterize their overall structure. The degree of a node is the number of edges connected to it. In directed graphs, you distinguish between in-degree (incoming edges) and out-degree (outgoing edges). Degree is fundamental because it tells you how connected a node is. In social networks, degree represents how many friends someone has. In transportation networks, degree represents how many direct routes a location has. High-degree nodes are often important or influential in the graph.</p>

        <p>The path length between two nodes is the number of edges in the shortest path connecting them. Diameter of a graph is the longest shortest-path between any two nodes, representing the maximum distance you'd have to travel between any pair of nodes. Average path length is the average distance between all pairs of nodes. These properties tell you how spread out the graph is. A graph where you can reach most nodes in few steps is highly connected. A graph with long paths indicates clusters of nodes far from each other.</p>

        <p>Density of a graph measures how many edges exist compared to the maximum possible. A complete graph where every pair of nodes is connected has maximum density. A sparse graph with few edges has low density. Density affects algorithm performance: dense graphs benefit from matrix representations, sparse graphs from list representations. Connected components are subsets of nodes where any two nodes in the subset can reach each other, but nodes from different components can't. A graph might have one connected component or many, which affects analysis.</p>

        <p>Clustering coefficient measures whether nodes tend to form tight triangular groups. If your friends are likely to also be friends with each other, you're in a high-clustering-coefficient neighborhood. Real-world networks often have high clustering, reflecting how relationships form clusters. These statistical properties let you characterize graphs succinctly and compare graphs to understand whether they have similar structures despite different applications. They're also useful for algorithms that assume certain graph properties.</p>
      </div>

      <div class="teaching-box">
        <p>Just as you might characterize a person by statistics like height, weight, and age, you can characterize graphs by statistics like degree, diameter, and clustering coefficient. These numbers don't capture every detail, but they give you a sense of the overall structure. A social network with high clustering and short average paths looks like many interconnected friend groups. A network with low clustering and long paths looks like scattered clusters far from each other. Understanding these statistics helps you recognize patterns in graphs and predict how they'll behave.</p>
      </div>
    </div>

  </section>

  <section>
    <div class="section-label">Understanding Graphs Holistically</div>
    <h2 class="section-title">Why Graphs Matter: The Universal Language of Connections</h2>

    <div class="insight-box" style="--insight-color: var(--cool);">
      <div class="insight-title">Graphs Capture the Essential Relational Structure of the World</div>
      <div class="insight-content">Whether you're modeling social relationships, transportation systems, molecules, or ideas, the fundamental abstraction is the same: entities and connections between them. Graphs provide a universal language for describing these structures. The power comes from this generality: once you understand graph concepts and algorithms, you can apply them across wildly different domains. A social network analyst might use the same community-finding algorithm as a biologist studying protein interaction networks, even though proteins and people seem completely different. The abstraction reveals common structure underneath superficially different phenomena.</div>
    </insight-box>

    <div class="insight-box" style="--insight-color: var(--green);">
      <div class="insight-title">Representation Choices Have Real Consequences</div>
      <div class="insight-content">How you represent a graph computationally affects what you can compute efficiently. An adjacency matrix makes some operations fast but wastes space on sparse graphs. An adjacency list saves space but makes some operations slower. Understanding when to use each representation requires understanding both your graph's structure and what operations you'll perform. This is a recurring theme in computer science: the right data structure for your problem can mean the difference between a solution running instantly or taking hours. Graph representation choices are one of the most important examples of this principle.</div>
    </insight-box>

    <div class="insight-box" style="--insight-color: var(--warm);">
      <div class="insight-title">Graph Statistics Enable Understanding at Scale</div>
      <div class="insight-content">When graphs have thousands or millions of nodes and edges, you can't manually inspect them to understand their structure. Statistics and global properties provide a way to understand large graphs succinctly. By computing statistics like degree distribution, clustering coefficient, and connected components, you can get a sense of the graph's overall structure without examining every node and edge. These statistics also provide baselines for comparison: if your network has much higher clustering than a random network, that tells you something about its structure. Statistics enable scaling your understanding to graphs too large to visualize or manually analyze.</div>
    </insight-box>

  </section>

</div>

<footer>
  <p class="footer-text">Graph Concepts ‚Äî The Language of Networks and Relationships</p>
</footer>

</body>
</html>
